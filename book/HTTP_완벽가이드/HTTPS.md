## HTTPS 
* HTTPS 는 HTTP의 가장 유명한 보안 버전
* HTTPS 는 HTTP 프로토콜에 대칭, 비대칭 인증서 기반 암호 기법의 강력한 집합을 결합한 형태
* 암호기법들의 집합은 무정부 상태의 분권화된 인터넷 환경에서도 HTTPS 를 매우 안전하고 유연하게, 관리하기 쉽게 만들어 준다.

> HTTPS 를 사용할 때, 모든 HTTP 요청과 응답 데이터는 네트워크로 보내지기 전에 __암호화__ 된다. HTTPS 는 HTTP 하부에 전송 레벨 암호 보안 계층을 제공함으로써, 동작한다. 해당 보안 계층을 Secure Socket Layer, SSL 이라고 부른다. 또는 Transport Layer Security, TLS 라고 부른다. 대부분의 인코딩 및 디코딩 작업은 SSL 라이브러리 안에서 일어나기 때문에 보안 HTTP 를 사용하기 위해 웹클라이언트와 서버가 프로토콜을 처리하는 로직을 크게 변경할 필요가 없다. 
   
<img src="https://github.com/pasudo123/SoftwareZeroToALL/blob/master/Image/http%2C%20https.png" width="500" >
  
> 사용자가 HTTPS 를 통한 안전한 웹 트랜잭션을 시작할 때, 최신 브라우저는 자동으로 접속한 서버에 디지털 인증서를 가져온다. 만약 서버가 인증서를 가지고 있지 않다면 보안 커넥션은 실패한다.

## 서버 인증서가 가지고 있는 정보
* 웹 사이트의 이름과 호스트 명
* 웹 사이트의 공개키
* 서명 기관의 이름
* 서명 

1. 브라우저가 인증서를 받으면 서명 기관을 검사한다.
2. 만약 그 기관이 공공이 신뢰할만한 기관이라면 브라우저는 그것의 공개키를 알고있기 때문에 해당 서명을 검증할 수 있다.
3. 민약 서명 기관이 모르는 곳이라면, 브라우저는 그 서명 기곤을 신뢰해야 할 지 확신할 수 없다.
4. 신뢰할 수 없는 경우, 해당 기관 신뢰여부를 확인하기 위해 대화상자를 보여준다.

## HTTPS 개요
* HTTPS 는 보안 전송 계층을 통해서 전송되는 HTTP 이다.
* 오늘날, HTTPS 의 보안 계층은 SSL 과 TLS 로 구현되었다.

### HTTPS 스킴
* HTTP 와 HTTPS 는 선택적이다.
* 만약 __URL 이 HTTP 스킴__ 을 가지고 있다면, 클라이언트는 서버에 80번(기본값) 포트로 연결하고 평범한 HTTP 명령을 전송
* 만약 __URL 이 HTTPS 스킴__ 을 가지고 있다면, 클라이언트는 서버에 443(기본값) 포트로 연결하고 서버와 바이너리 포맷으로 된 몇몇 SSL보안 매개변수를 교환하면서 "핸드세이크" 를 진행하고 암호회된 HTTP 명령의 뒤를 잇는다.
   
* SSL 트래픽은 바이너리 프로토콜이기 때문에 HTTP 와 완전히 다르다.

### SSL HandShake
암호화된 HTTP 메시지를 보낼 수 있게 되기 전에, 클라이언트와 서버는 SSL 핸드셰이크를 할 필요가 있다.
* 프로토콜 버전 번호 교환
* 양쪽이 알고있는 암호 선택
* 양쪽의 신원을 인증
* 채널을 암호화하기 위해 임시 세션 키 생성

### 서버 인증서
* SSL 은 서버인증서를 클라이언트로 전송하고, 클라이언트 인증서를 서버로 날라주는 상호 인증을 지원한다.
* 오늘날 클라이언트 인증서는 웹 브라우징에선 흔히 쓰이지 않는다. 대부분 사용자는 개인 클라이언트 인증서를 갖고 있지도 않다.
* 보안 HTTPS 트랜잭션은 항상 서버 인증서를 요구한다.
  * 누군가 웹 서버에 신용카드 정보를 보내는 것과 같은 보안 트랜잭션을 수행하는 경우, 그는 대화 중인 조직이 그와 대화하고 있는 조직이 맞는지 확인하고 싶을 것이다. 인증기관에 의해 서명된 서버 인증서는 그가 서버에 그의 신용카드나 개인 정보를 보내기 전에 그 서버를 얼마나 신뢰할 수 있는지 평가하는 것을 도와줄 것이다.

